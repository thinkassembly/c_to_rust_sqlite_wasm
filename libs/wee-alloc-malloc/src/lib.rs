// Copyright 2017-2018 the authors. See the 'Copyright and license' section of
// the README.md file at the top-level directory of this repository.
//
// Licensed under the Apache License, Version 2.0 (the LICENSE-APACHE file) or
// the MIT license (the LICENSE-MIT file) at your option. This file may not be
// copied, modified, or distributed except according to those terms.

//! Bindings for the C `malloc` API to Rust allocators.
//!
//! This crate provides a mechanism to construct a C allocator - implementations of `malloc`,
//! `free`, and related functions - that is backed by a Rust allocator (an implementation of the
//! `Alloc` trait).
//!
//! In order to create bindings, an implementation of the `Alloc` trait must be extended to also
//! implement the `LayoutFinder` and `Malloc` traits (defined in this crate). The `Malloc` trait
//! provides one method for each function in the C API (default implementations are provided which
//! use the methods of the `Alloc` trait, but these can be overridden if needed). Since the C API
//! does not provide size or alignment when passing a pointer to an existing allocation (`free`,
//! `realloc`, etc), but the Rust `Alloc` API requires both size and alignment for these methods,
//! a mapping must be maintained between allocated objects and those objects' size and alignment.
//! The `LayoutFinder` trait provides this functionality.

// TODO:
// - Windows:
//   - Support _heapmin (https://msdn.microsoft.com/en-us/library/fc7etheh.aspx)
//   - Support _set_new_handler (https://msdn.microsoft.com/en-us/library/a45x8asx.aspx) (and call
//     the registered handler in various functions)

#![feature(allocator_api)]
#![feature(alloc)]
#![feature(core_intrinsics)]
#![feature(const_fn)]
#![feature(layout_for_ptr)]

#[repr(u8)]
pub enum c_void {
    // Two dummy variants so the #[repr] attribute can be used.
    #[doc(hidden)]
    __variant1,
    #[doc(hidden)]
    __variant2,
}
pub type size_t = usize;

extern crate alloc;
// lazy_static's macros are only used in the macros we define, so if no macros are called (which is
// the case when compiling this crate on its own), then lazy_static's macros (and thus the
// #[macro_use] attribute) will appear unused.
#[allow(unused_imports)]
#[macro_use]
extern crate lazy_static;
use alloc::alloc::{GlobalAlloc, Layout};

extern crate wee_alloc;

// Export these so that they can be used from the macros as $crate::c_void and $crate::size_t.
// See https://users.rust-lang.org/t/how-to-import-in-a-macro-without-conflicting/12785 for why
// this is necessary.

#[doc(hidden)]

/// A mechanism for mapping allocated objects to their `Layout`s.
///
/// A `LayoutFinder` is an object that can store and look up the `Layout` associated with an
/// allocated object. In the functions generated by this crate, newly-allocated objects will be
/// inserted into a global `LayoutFinder` object, and this `LayoutFinder` will be used to look up
/// the `Layout`s associated with objects passed to `free` and other functions.
///
/// # Safety
///
/// This trait is unsafe because an incorrect implementation could result in invalid arguments
/// getting passed to unsafe methods of the `Alloc` trait.
pub unsafe trait LayoutFinder {
    /// Get the `Layout` associated with an allocated object.
    ///
    /// `get_layout` is passed a pointer to an allocated object, and it returns a `Layout`
    /// describing that object. `ptr` is guaranteed to be an object previously allocated using one
    /// of the various C allocation functions.
    ///
    /// # Safety
    ///
    /// This method is unsafe because implementations may dereference `ptr`, rely on it having been
    /// allocated by this allocator, or rely on it having been inserted using `insert_layout`.
    unsafe fn get_layout(&self, ptr: *mut u8) -> Layout;

    /// Insert a new object to `Layout` mapping.
    ///
    /// `insert_layout` is passed a pointer to a newly-allocated object and a `Layout` describing
    /// that object, and it stores this mapping. `insert_layout` is called immediately after
    /// allocation in all of the C allocation functions.
    ///
    /// The default implementation of `insert_layout` is a no-op, as some allocators may already
    /// keep track of the information necessary to implement `get_layout` internally.
    ///
    /// # Safety
    ///
    /// This method is unsafe because implementations may dereference `ptr`, rely on it having been
    /// allocated by this allocator, or rely on it not having already been inserted.
    unsafe fn insert_layout(&self, _ptr: *mut u8, _layout: Layout) {}

    /// Delete an existing object to `Layout` mapping.
    ///
    /// `delete_layout` is passed a pointer to an object whose mapping has previously been
    /// inserted, and it deletes this mapping. `delete_layout` is called immediately after
    /// deallocation in all of the C deallocation functions.
    ///
    /// The default implementation of `delete_layout` is a no-op, as some allocators may already
    /// keep track of the information necessary to implement `get_layout` internally.
    ///
    /// # Safety
    ///
    /// This method is unsafe because implementations may dereference `ptr`, rely on it having been
    /// allocated by this allocator, or rely on it already having been inserted using
    /// `insert_layout`.
    unsafe fn delete_layout(&self, _ptr: *mut u8) {}
}

// See the posix_memalign manpage on Linux, the malloc manpage on Mac, or
// https://msdn.microsoft.com/en-us/library/6ewkz86d.aspx on Windows.
//
// According to the Linux posix_memalign manpage, "The glibc malloc(3) always returns 8-byte
// aligned memory addresses..." According to the Mac malloc manpage, "The allocated memory is
// aligned such that it can be used for any data type, including AltiVec- and SSE-related types."
// According to the linked Windows documentation, "The storage space pointed to by the return value
// is guaranteed to be suitably aligned for storage of any type of object that has an alignment
// requirement less than or equal to that of the fundamental alignment. (In Visual C++, the
// fundamental alignment is the alignment that's required for a double, or 8 bytes. In code that
// targets 64-bit platforms, itâ€™s 16 bytes.)"
//
// Thus, we align all allocations to these alignments. Since the Rust Layout type requires that
// size be a multiple of alignment, we also round up the size to be a multiple of the alignment.
//
// On Linux, it is valid for malloc(0) to return NULL, so for all 0-sized allocations, we return
// NULL. On Mac, this allowance is not explicitly documented, so we err on the side of caution and
// round up 0-sized allocations as we would any other allocation. On Windows, it is explicitly
// documented that 0-sized allocations return pointers into the heap: "If size is 0, malloc
// allocates a zero-length item in the heap and returns a valid pointer to that item." Thus, we
// round up 0-sized allocations on Windows as well.

/// The minimum alignment guaranteed by some allocation functions.
///
/// Some allocation functions guarantee an alignment of `MIN_ALIGN`. This alignment is 8 on Linux
/// and 32-bit Windows, and 16 on Mac and 64-bit Windows.
pub const MIN_ALIGN: size_t = __MIN_ALIGN;

const __MIN_ALIGN: size_t = 8;

/// The size of a C `void *`.
///
/// `WORD_SIZE` is the size of a pointer, equivalent to `sizeof(void *)` in C.
pub const WORD_SIZE: usize = core::mem::size_of::<*mut c_void>();

/// An implementation of the C allocation API.
///
/// The `Malloc` trait extends a type which implements `Alloc` for a reference to
/// itself<sup>1</sup> by
/// providing methods for the various functions of the C allocation API. As `Malloc` also extends
/// `LayoutFinder`, it provides default implementations of each method in terms of the
/// `LayoutFinder` and `Alloc` methods. Alternatively, any method may be overridden with a custom
/// implementation.
///
/// Having implemented `Malloc`, most users will want to use the `define_malloc` or
/// `define_malloc_lazy_static` macros, which take care of wrapping each method in an `extern "C"`
/// function that can be called from C code. Users who wish to expose only a subset of this API
/// will need to define the `extern "C"` functions manually.
///
/// 1. `Malloc` requires an immutable reference to implement `Alloc` (rather than simply extending
///    `Alloc` itself) so that its own methods can be immutable. This is required because C allows
///    the functions of the allocation API to be called from multiple threads at once.
pub unsafe trait Malloc: GlobalAlloc + LayoutFinder {
    /// The C `malloc` function.
    ///
    /// `malloc` allocates storage sufficient to hold `size` bytes, and returns a pointer to it.
    /// The allocated memory is aligned to `MIN_ALIGN`. The memory is not initialized. If there is
    /// insufficient space to perform the allocation, `errno` is set to `ENOMEM` and the return
    /// value is `NULL`.
    ///
    /// # Platform-specific behavior
    ///
    /// On Linux, if `size` is 0, `malloc` returns either `NULL` or a unique pointer that can later
    /// be passed to `free`. On Mac and Windows, if `size` is 0, an allocation must still be
    /// created on the heap such that two different 0-sized allocations result in two distinct
    /// pointers.
    unsafe fn c_malloc(&self, size: size_t) -> *mut c_void {
      if unlikely(size == 0) {
            return ptr::null_mut();
        }

        let size = roundup(size, MIN_ALIGN);
        let layout = layout_from_size_align(size as usize, MIN_ALIGN);
        // TODO: Check _HEAP_MAXREQ on Windows? "malloc sets errno to ENOMEM if a memory allocation
        // fails or if the amount of memory requested exceeds _HEAP_MAXREQ."
        let ptr = self.alloc(layout.clone());
        if !ptr.is_null() {
            self.insert_layout(ptr, layout);
        } else {
        }
        ptr as *mut c_void
    }

    /// The C `free` function.
    ///
    /// `free` frees a previous allocation. If `ptr` is `NULL`, `free` does nothing. The behavior
    /// of `free` is undefined if `ptr` does not represent a previous allocation, or if `ptr` has
    /// already been freed.
    unsafe fn c_free(&self, ptr: *mut c_void) {
        if unlikely(ptr.is_null()) {
            // Linux/Mac: "If ptr is a NULL pointer, no operation is performed."
            // Windows: "If memblock is NULL, the pointer is ignored and free immediately returns."
            return;
        }

        let layout = self.get_layout(ptr as *mut u8);
        self.delete_layout(ptr as *mut u8);
        self.dealloc(ptr as *mut u8, layout);
    }

    /// The C `realloc` function.
    ///
    /// `realloc` changes the size of the allocation pointed to by `ptr` to `size` bytes, returning
    /// the address of the modified allocation (which may be different from `ptr`). The contents
    /// will be unchanged in the range from the start of the allocation to the minimum of the old
    /// and new sizes. If the new size is larger than the old size, the added memory will not be
    /// initialized. If `ptr` is `NULL`, then the call is equivalent to `malloc(size)`. If the
    /// allocation request fails, the original allocation is left untouched, `errno` is set to
    /// `ENOMEM`, and the return value is `NULL`.
    ///
    /// # Platform-specific behavior
    ///
    /// On Linux and Windows, if `size` is 0 and `ptr` is not `NULL`, then `realloc` is equivalent
    /// to `free(ptr)`, and the return value is `NULL`. On Mac, if `size` is 0 and `ptr` is not
    /// `NULL`, then `realloc` allocates a new 0-sized object with the same guarantees as
    /// `malloc(0)` and, if this allocation succeeds, frees `ptr`.
    unsafe fn c_realloc(&self, ptr: *mut c_void, size: size_t) -> *mut c_void {
        // See http://man7.org/linux/man-pages/man3/malloc.3.html,
        // http://www.manpagez.com/man/3/malloc/osx-10.6.php

        if ptr.is_null() {
            // Linux: "If ptr is NULL, then the call is equivalent to malloc(size), for all values
            // of size."
            // Mac: "If ptr is NULL, realloc() is identical to a call to malloc() for size bytes."
            // Windows: "If memblock is NULL, realloc behaves the same way as malloc and allocates
            // a new block of size bytes."
            return self.c_malloc(size);
        }

        if unlikely(size == 0) {
            // Linux: "if size is equal to zero, and ptr is not NULL, then the call is equivalent
            // to free(ptr)."
            // Windows (https://msdn.microsoft.com/en-us/library/xbebcx7d.aspx): "If size is zero,
            // then the block pointed to by [ptr] is freed; the return value is NULL, and [ptr] is
            // left pointing at a freed block."
            self.c_free(ptr);
            return ptr::null_mut();
        }

        // Mac: "If size is zero and ptr is not NULL, a new, minimum sized object is allocated
        // and the original object is freed."
        //
        // Since "minimum sized object" isn't defined in the manpage, we take it to mean an object
        // at least as large as the minimum alignment. Luckily, we don't need any special-cased
        // logic since 'roundup(size, MIN_ALIGN)' will handle this for us. Note that while the
        // manpage requires that a new object is allocated and the old one freed, realloc'ing works
        // just as well because the caller cannot rely on the contents of a newly-allocated object,
        // and thus the new object sharing memory with the old object is fine.

        let size = roundup(size, MIN_ALIGN);
        let layout = self.get_layout(ptr as *mut u8);
        let new_layout = layout_from_size_align(size as usize, MIN_ALIGN);
        let ptr = self.alloc(layout.clone());
        if !ptr.is_null() {
            self.delete_layout(ptr);
            self.insert_layout(ptr, new_layout);
        } else {
            // Linux: "The realloc() function returns... NULL if the request
            // fails... If realloc() fails, the original block is left
            // untouched; it is not freed or moved."
            // Mac: "If there is an error, [realloc] return[s] a NULL pointer
            // and set[s] errno to ENOMEM. For realloc(), the input pointer is
            // still valid if reallocation failed."
            // Windows: "If there is not enough available memory to expand the
            // block to the given size, the original block is left unchanged,
            // and NULL is returned."
        }
        ptr as *mut c_void
    }
}

#[cfg_attr(feature = "cargo-clippy", allow(inline_always))]
#[inline(always)]
fn roundup(n: size_t, multiple: size_t) -> size_t {
    if n == 0 {
        return multiple;
    }
    let remainder = n % multiple;
    if remainder == 0 {
        n
    } else {
        n + multiple - remainder
    }
}

#[cfg_attr(feature = "cargo-clippy", allow(inline_always))]
#[inline(always)]
unsafe fn layout_from_size_align(size: usize, align: usize) -> Layout {
    if cfg!(debug_assertions) {
        Layout::from_size_align(size as usize, align).unwrap()
    } else {
        Layout::from_size_align_unchecked(size as usize, align)
    }
}

// TODO: In the macros, how do we ensure that the right types are imported (Malloc, size_t, c_void)
// while not conflicting with existing imports if they're already imported.

/// Define `extern "C"` functions for the C allocation API.
///
/// `define_malloc` is a convenience macro that constructs a global instance of a `Malloc` type and
/// defines each of the functions of the C allocation API by calling methods on that instance. One
/// function is defined for each of the methods on `Malloc` (`malloc` for the `c_malloc` method,
/// `free` for the `c_free` method, etc). Users who only want to define a subset of the C
/// allocation API should instead define these functions manually.
///
/// `define_malloc` takes an allocator type and an expression to construct a new instance of that
/// type. The expression must be a constant expression, as it will be used in the initialization of
/// a static variable. If the expression needs to be non-constant, use `define_malloc_lazy_static`
/// instead.
#[macro_export]
macro_rules! define_malloc {
    ($alloc_ty:ty, $alloc_new:expr) => {
        static __HEAP: $alloc_ty = $alloc_new;

        #[no_mangle]
        pub extern "C" fn malloc(size: $crate::size_t) -> *mut $crate::c_void {
            // Do this here (rather than at the top-level) so as not to conflict with existing
            // macros if the user has already imported Malloc.
            use $crate::Malloc;
            unsafe { __HEAP.c_malloc(size) }
        }

        #[no_mangle]
        pub extern "C" fn free(ptr: *mut $crate::c_void) {
            use $crate::Malloc;
            unsafe { __HEAP.c_free(ptr) }
        }

        #[no_mangle]
        pub extern "C" fn realloc(
            ptr: *mut $crate::c_void,
            size: $crate::size_t,
        ) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_realloc(ptr, size) }
        }
    };
}

// This line re-exports the macros from lazy_static so that they'll be available to the code
// calling define_malloc_lazy_static. This allows define_malloc_lazy_static to be used without the
// caller needing to know about lazy_static and import its macros themselves.
//
// Credit to https://users.rust-lang.org/t/how-to-use-macro-inside-another-macro/12061/2
#[doc(hidden)]
pub use lazy_static::*;
use std::intrinsics::unlikely;
use std::ptr;
/// Define `extern "C"` functions for the C allocation API with a non-constant initializer.
///
/// `define_malloc_lazy_static` is like `define_malloc`, except there is no requirement that the
/// initialization expression must be constant. Instead, `lazy_static` is used to construct the
/// global `Malloc` instance.
#[macro_export]
macro_rules! define_malloc_lazy_static {
    ($alloc_ty:ty, $alloc_new:expr) => {
        lazy_static! {
            static ref __HEAP: $alloc_ty = $alloc_new;
        }

        #[no_mangle]
        pub extern "C" fn malloc(size: $crate::size_t) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_malloc(size) }
        }

        #[no_mangle]
        pub extern "C" fn free(ptr: *mut $crate::c_void) {
            use $crate::Malloc;
            unsafe { __HEAP.c_free(ptr) }
        }

        #[no_mangle]
        pub extern "C" fn realloc(
            ptr: *mut $crate::c_void,
            size: $crate::size_t,
        ) -> *mut $crate::c_void {
            use $crate::Malloc;
            unsafe { __HEAP.c_realloc(ptr, size) }
        }
    };
}

unsafe impl Malloc for std::alloc::System {}
unsafe impl LayoutFinder for std::alloc::System {
    unsafe fn get_layout(&self, ptr: *mut u8) -> Layout {

      let lay =  Layout::from_size_align(   roundup(std::mem::size_of_val_raw(&ptr), MIN_ALIGN),MIN_ALIGN).unwrap();
        println!("{:?}",lay);
        lay

    }
}
